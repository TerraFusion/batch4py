import uuid
import os
import subprocess
from collections import defaultdict
import uuid
import errno
import time
from abc import ABC, abstractmethod
from batch4py import constants
import subprocess

class Job(ABC):
    
    _valid_sched = { 'pbs' : 'qsub' }
    '''Scheduler name to executable mappings'''

    def __init__( self, script, script_type=None, account=None ):
        '''
**DESCRIPTION**  
    Class responsible for submitting a single job to the PBS scheduler.  
**ARGUMENTS**  
    *script*  (str) -- Path to file, or string literal for the PBS script.  
    *script_type* (str) -- Choose from { 'file', 'literal' }. Specifies 
        whether script is a path (file) or a string literal. If it is literal,
        script is interpreted to be a file literal, in which case script
        will be printed to a file before passing to the scheduler. This file 
        will be stored in batch4py's installation directory.  

    *account* (str)   -- Specify any PBS account to submit the job under.  

**EFFECTS**  
    Submits job to the scheduler  
**RETURN**
    None
        '''
        # Generate a unique ID for this job
        self._id            = uuid.uuid4()

        # JOB SCRIPT
        #----------------------------------------------------------
        self.script    = None                                #
        self._set_script( script, script_type )                    #
        #----------------------------------------------------------

        # SCHEDULER VARIABLES
        #---------------------------------------------------------------
        # _sched_id is ID that scheduler itself will provide later on  #
        self._sched_id          = None                                 #
        self._sched_type        = None                                 #
        # override_sched changes behavior of sched_type interpretation #
        self._sched_override    = False                                #
        #---------------------------------------------------------------

        self._extra_cmd = []

    def __hash__(self):
        return hash( self._id )

    @abstractmethod
    def set_config( self ):
        ''' 
        Sets configuration parameters (nodes, walltime, etc.) for the job
        '''
        
        pass

    @abstractmethod
    def submit( self, dependency = None, params = None, stdin=None, stdout=None, 
                stderr=None, dry_run = False ):
        ''' Submits the job to the system job scheduler.  '''
        pass 
    
   
    def add_param( self, params ):
        '''
        Add additional command-line parameters to the scheduler.

        params is a list of str, where each str is a single 
        command-line parameter to pass to the scheduler executable.
        Multiple parameters should NOT be separated by spaces, but
        by separate entries into the list:

        ex:

        ls -l . --> params = ['ls', '-l', '.']

        Each parameter is sanitized by encapsulating in single quotes.
        '''

        # Arbitrary code execution is always dangerous. Let's sanitize
        # each parameter by surrounding it with single quotes.

        for val in params:
            new_val = "'" + val.strip() + "'"
            self._extra_cmd.append( new_val )

        '''
        Return path of self's scheduler file.
        '''

        return self.script

    def _set_script( self, script, type = None ):
        '''
**DESCRIPTION**  
    Set the scheduler script to use for this job. Can either pass in a script
    literal or a path to a file. By default, function will attempt to
    interpret argument 'script' as either a literal or an existing file.

    This function should normally never be called because it is implicitly
    called in the class's constructor.  
**ARGUMENTS**  
    *script* (str)  -- Script literal or path to a script  
    *type* (str)   -- Set to 'file' or 'literal' to force interpretation of
        script.  
**EFFECTS**  
    Stores *script* in self's attributes.  
**RETURN**  
    None
        '''
        supported_types = ['file', 'literal']
        if type is not None and type not in supported_types:
            raise ValueError("Argument 'type' not a valid value.")

        # is_file expression generated by solving a Karnaugh map
        is_file = ( type is None and os.path.isfile( script ) ) or type == 'file'

        if not is_file:
            # Assign a unique name to PBS file and write the string literal 
            # to it
            pbs_name = '{}.pbs'.format( self._id )
            script_path = os.path.join( constants.PBS_DIR, pbs_name )
            
            try:
                os.makedirs( constants.PBS_DIR )
            except OSError as e:
                if e.errno != errno.EEXIST:
                    raise
            
            with open( script_path, 'w' ) as f:
                f.write( script )

                script = script_path

        self.script = os.path.abspath( script )

    def get_script(self):
        '''
        Return path of self's scheduler file.
        '''

        return self.script

    def get_id( self ):
        '''
**DESCRIPTION**  
    Get the internal uuid identifier of self.  
**ARGUMENTS**  
    None  
**EFFECTS**  
    None  
**RETURN**  
    uuid object
        '''
        return self._id

    def set_sched_id( self, id ):
        '''
**DESCRIPTION**  
    Set self's identifier given by the system's scheduler.  
**ARGUMENTS**  
    *id* (str)  -- Identifier understood by the system scheduler.  
**EFFECTS** 
    Sets self's scheduler ID attribute.  
**RETURN**  
    None
        '''
        if not isinstance( id, str ):
            raise TypeError("Argument 'id' is not a str.")
        self._sched_id = id

    def get_sched_id( self ):
        '''
**DESCRIPTION**  
    Return self's ID as given by the system scheduler. Attribute will not
    contain a valid value until self is submitted to the scheduler 
    using submit().  
**ARGUMENTS**  
    None  
**EFFECTS**  
    None  
**RETURN**  
    Scheduler ID (str)
        '''
        if self._sched_id is None:
            raise RuntimeError("job hasn't been submitted to the queue yet.")

        return self._sched_id


class TORQUE(Job):

    config = constants.CONFIG['torque']
    
    def __init__(self, script, script_type = None, name = None, 
                 nodes = None, ppn = None, walltime = None, 
                 node_type = None, account = None ):

        super().__init__( script, script_type )

        self.command = ''
        self.dependents = []
        self.nodes = nodes
        self.ppn = ppn
        self.walltime = walltime
        self.account = account
        self.node_type = node_type
        self.name = name

        self.allowed_keys = [ a for a in dir(self) if not a.startswith('__') ]

    def set_config( self, **kwargs ):
        
        # allowed_keys will only be atrributes explicitly defined in __init__
        for k, v in kwargs.items():
            if k in self.allowed_keys:
                self.__dict__.update( {k:v} )
            else:
                raise KeyError('{} not a valid configuration parameter.'.format( k ) )

    def depends( self, target, type ):
        '''
        Set a dependency for this job.
        '''
        if type not in self.config['supported_dep']:
            raise ValueError('type not supported.')

        self.dependents.append( [target, type] )

    def get_deps( self ):
        '''
        Return self's dependency list.
        '''

        return self.dependents

    def submit( self, dry_run = False, stdout=None, stderr=None ):
        """
        Submit the job to the scheduler.
        dry_run -- If set to True, job will not actually be submitted to the scheduler.
        stdout -- File object for scheduler call's stdout
        stderr -- File object for scheduler call's stderr

        If stdout/stderr is not supplied, the corresponding output stream will
        simply be printed.
        """
        dep = defaultdict(list)
        # Create the command line arguments
        args = []
        # append executable name
        if self._sched_override:
            args.append( self._sched_type )
        else:
            args.append( self.config['exe'] )

        # Add extra commands
        args = args + self._extra_cmd

        deptype = {}
        # Add PBS dependencies
        if self.dependents:
            args.append( self.config['attribute'] )
            for dep in self.dependents:
                
                # Add list to this key if we haven't seen it before
                if dep[1] not in deptype:
                    deptype[dep[1]] = []

                # Append to the list
                deptype[ dep[1] ].append( dep[0] )

            dep_str = ""
            for type in deptype:
                if dep_str:
                    dep_str = dep_str + ","
                else:
                    dep_str = "depend="

                dep_str = dep_str + type
                for dep in deptype[type]:
                    dep_str = "{}{}{}".format( dep_str, self.config['delimit'], dep.get_sched_id())

            args.append( dep_str )

        # Add node requirements
        if self.nodes:
            args.append( self.config['resource'] )
            args.append( 'nodes={}'.format( self.nodes ) )
        if self.ppn:
            args.append( self.config['resource'] )
            args.append( 'ppn={}'.format( self.ppn ) + 
                '{}'.format(self.config['delimit'] + self.node_type) if self.node_type
                else '' )
        if self.walltime:
            args.append( self.config['resource'] )
            args.append( self.walltime )
        if self.account:
            args.append( self.config['account'] )
            args.append( self.account )
        if self.name:
            args.append( self.config['job_name'] )
            args.append( self.name )

        args.append( self.script )

        # We cd to the location of the PBS script because PBS will print out
        # log files in its current working directory. Just keep them all in
        # one place.
        os.chdir( os.path.dirname( self.script ) )

        if dry_run:
            print('\nDry run submission.')

        print( ' '.join(args) )
        
        if not dry_run:
            subproc = subprocess.Popen( args, stdout=subprocess.PIPE, stderr=subprocess.PIPE )
            retcode = subproc.wait()

            # Retrieve the scheduler ID
            stderrFile = subproc.stderr
            sub_stderr = stderrFile.read()
            stdoutFile = subproc.stdout
            sub_stdout = stdoutFile.read()

            if stdout:
                stdout.write( str( sub_stdout, 'utf-8') )
            else:
                print(str(sub_stdout, 'utf-8'))
            if stderr:
                stderr.write( str(sub_stderr, 'utf-8') )
            else:
                print(str(sub_stderr, 'utf-8'))

            if retcode != 0:
                raise RuntimeError('Process exited with retcode {}'.format(retcode))

            self._sched_id = sub_stdout.strip().decode('UTF-8')
        else:
            # Use internal identifier instead of scheduler-supplied ID
            self._sched_id = str(self._id)
